<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>D√°niel √©s az oroszl√°nverem</title>
  <style>
    :root { --bg1:#0b1020; --bg2:#1a0f1f; --ui:#e8e8e8; }
    html, body { height: 100%; margin: 0; background: #000; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #wrap {
      height: 100%;
      display: grid;
      place-items: center;
      background: radial-gradient(1200px 800px at 50% 30%, rgba(255,255,255,0.06), transparent 60%),
                  linear-gradient(180deg, var(--bg1), var(--bg2));
      touch-action: none; /* important for mobile drag */
      user-select: none;
      -webkit-user-select: none;
    }
    canvas {
      width: min(96vw, 560px);
      height: calc(min(96vw, 560px) * 1.6);
      max-height: 92vh;
      background: rgba(0,0,0,0.18);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.45);
    }
    .hud {
      position: fixed;
      top: 10px; left: 0; right: 0;
      display: flex;
      justify-content: center;
      pointer-events: none;
    }
    .hud > div {
      width: min(96vw, 560px);
      display: flex;
      align-items: center;
      justify-content: space-between;
      color: var(--ui);
      font-size: 14px;
      letter-spacing: 0.2px;
      opacity: 0.92;
      padding: 0 8px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.6);
    }
    .pill {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
    }
    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }
    .card {
      width: min(92vw, 520px);
      color: var(--ui);
      background: rgba(15, 15, 20, 0.88);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 18px;
      padding: 16px 16px 14px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.55);
    }
    .card h1 { margin: 0 0 8px; font-size: 18px; }
    .card p { margin: 8px 0; line-height: 1.35; opacity: 0.95; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 12px; }
    button {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: var(--ui);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 600;
      cursor: pointer;
    }
    button:active { transform: translateY(1px); }
    .hint {
      font-size: 12px;
      opacity: 0.85;
    }
    .freezeFlash {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: rgba(120, 180, 255, 0.16);
      opacity: 0;
      transition: opacity 120ms ease;
    }
    .freezeFlash.on { opacity: 1; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding: 1px 6px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.08); }
  </style>
</head>
<body>
  <div class="hud">
    <div>
      <div class="pill">‚è±Ô∏è <span id="time">0.0</span>s / <span id="goal">20</span>s</div>
      <div class="pill">üôè Ima: <span id="prayer">K√âSZ</span></div>
    </div>
  </div>

  <div id="wrap">
    <canvas id="c" width="560" height="896" aria-label="J√°t√©k v√°szon"></canvas>
  </div>

  <div class="freezeFlash" id="flash"></div>

  <div class="overlay" id="overlay">
    <div class="card">
      <h1 id="title">D√°niel √©s az oroszl√°nverem</h1>
      <p id="msg"></p>
      <p class="hint" id="hint"></p>
      <div class="row">
        <button id="btnStart">Start</button>
        <button id="btnRetry" style="display:none;">√öjra</button>
      </div>
    </div>
  </div>

  <script>
    // ---------------------------
    // CONFIG (itt √°ll√≠tgasd)
    // ---------------------------
    const SOLUTION_HASH= "d4c0278b7d4dd8f2ca178f0367f8b5e866af4e10e54a1341623604b43a47695c"
    const SOL_PARTS = [
      "xZAgQVogw4lMxZAg",
      "SVNURU4gTUVHTUFS",
      "QUQgw5ZSw5ZLS8OJ",
    ];
    const CONFIG = {
      goalSeconds: 20,            // ennyit kell t√∫l√©lni a megold√°shoz
      lionSpawnEvery: 1100,       // ms: indul√≥ spawn gyakoris√°g
      lionSpawnMin: 400,          // ms: minimum spawn id≈ë a gyorsul√°s v√©g√©n
      lionSpeedBase: 80,          // px/s alap sebess√©g
      lionSpeedMax: 270,          // px/s max (id≈ëvel k√∂zel√≠t ide)
      lionRadius: 18,             // px
      playerRadius: 15,           // px
      freezeDuration: 2000,       // ms
      freezeCooldown: 8000,       // ms
      difficultyRampSeconds: 30,  // ~mennyi id≈ë alatt gyorsul fel durv√°n (gameplay-hez)
      maxLions: 100                // teljes√≠tm√©ny limit
    };

    // ---------------------------
    // SETUP
    // ---------------------------
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    const overlay = document.getElementById("overlay");
    const titleEl = document.getElementById("title");
    const msgEl = document.getElementById("msg");
    const hintEl = document.getElementById("hint");
    const btnStart = document.getElementById("btnStart");
    const btnRetry = document.getElementById("btnRetry");
    const timeEl = document.getElementById("time");
    const goalEl = document.getElementById("goal");
    const prayerEl = document.getElementById("prayer");
    const flash = document.getElementById("flash");

    goalEl.textContent = String(CONFIG.goalSeconds);

    // Fix CSS size -> internal resolution scaling
    function fitCanvasToCSS() {
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // cap for perf
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
    }
    window.addEventListener("resize", fitCanvasToCSS);

    // ---------------------------
    // GAME STATE
    // ---------------------------
    let running = false;
    let gameOver = false;
    let won = false;

    let tStart = 0;
    let lastFrame = 0;
    let survived = 0;

    const player = { x: 0, y: 0, r: CONFIG.playerRadius, targetX: 0, targetY: 0, dragging: false };
    let lions = [];
    let spawnTimer = 0;

    // Freeze
    let freezeUntil = 0;
    let freezeCooldownUntil = 0;

    // Double tap detection
    let lastTapAt = 0;
    const DOUBLE_TAP_MS = 260;

    // ---------------------------
    // UTIL
    // ---------------------------
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function dist2(ax, ay, bx, by) { const dx = ax - bx; const dy = ay - by; return dx*dx + dy*dy; }
    function lerp(a,b,t){ return a + (b-a)*t; }

    function cssW() { return canvas.getBoundingClientRect().width; }
    function cssH() { return canvas.getBoundingClientRect().height; }

    function resetGame() {
      fitCanvasToCSS();
      running = false; gameOver = false; won = false;
      survived = 0;
      lions = [];
      spawnTimer = 0;
      freezeUntil = 0;
      freezeCooldownUntil = 0;
      lastTapAt = 0;

      const w = cssW(), h = cssH();
      player.x = w * 0.5; player.y = h * 0.72;
      player.targetX = player.x; player.targetY = player.y;
      player.dragging = false;

      timeEl.textContent = "0.0";
      prayerEl.textContent = "K√âSZ";

      draw(); // initial frame
    }

    function showOverlay(kind) {
      overlay.style.display = "grid";
      btnStart.style.display = (kind === "start") ? "inline-block" : "none";
      btnRetry.style.display = (kind === "retry" || kind === "win") ? "inline-block" : "none";

      if (kind === "start") {
        titleEl.textContent = "D√°niel √©s az oroszl√°nverem";
        msgEl.textContent = `Tartsd √©letben D√°nielt ${CONFIG.goalSeconds} m√°sodpercig.`;
        hintEl.innerHTML = `Mozg√°s: h√∫zd az ujjad. Ima: <span class="kbd">dupla tap</span> (fagyaszt).`;
      } else if (kind === "retry") {
        titleEl.textContent = "V√©ge";
        msgEl.textContent = "Az oroszl√°nok ma nem voltak veget√°ri√°nusok.";
        hintEl.textContent = "√öjraind√≠t√°s: nyomd meg az √öjra gombot.";
      } else if (kind === "win") {
        titleEl.textContent = "Siker";
        msgEl.textContent = "‚ÄûIsten bez√°rta az oroszl√°nok sz√°j√°t.‚Äù";
        hintEl.textContent = revealSolution();
      }
    }

    function hideOverlay() { overlay.style.display = "none"; }
    
    const _0x9f2 = [
  197,144,32,65,90,32,195,137,76,197,144,32,
  73,83,84,69,78,32,
  77,69,71,77,65,82,65,68,32,
  195,150,82,195,150,75,75,195,137
];

const _0xa1c = [...Array(_0x9f2.length).keys()];

function revealSolution(){
  let _r = new Uint8Array(_0xa1c.length);
  for(let _i=0; _i<_0xa1c.length; _i++){
    _r[_i] = (_0x9f2[_0xa1c[_i]] ^ 0);
  }
  return new TextDecoder("utf-8").decode(_r);
}


    // Difficulty curve: 0..1 over ramp seconds
    function difficulty01() {
      const t = clamp(survived / CONFIG.difficultyRampSeconds, 0, 1);
      // easeOut-ish
      return 1 - Math.pow(1 - t, 2);
    }

    function currentLionSpeed() {
      const d = difficulty01();
      return lerp(CONFIG.lionSpeedBase, CONFIG.lionSpeedMax, d);
    }

    function currentSpawnEveryMs() {
      const d = difficulty01();
      return Math.floor(lerp(CONFIG.lionSpawnEvery, CONFIG.lionSpawnMin, d));
    }

    function spawnLion() {
      if (lions.length >= CONFIG.maxLions) return;

      const w = cssW(), h = cssH();
      const r = CONFIG.lionRadius;

      // spawn on edges
      const edge = Math.floor(Math.random() * 4);
      let x, y;
      if (edge === 0) { x = Math.random() * w; y = -r * 2; }         // top
      else if (edge === 1) { x = w + r * 2; y = Math.random() * h; } // right
      else if (edge === 2) { x = Math.random() * w; y = h + r * 2; } // bottom
      else { x = -r * 2; y = Math.random() * h; }                   // left

      lions.push({ x, y, r, wobble: (Math.random()*2-1)*0.8 });
    }

    function tryFreeze(now) {
      if (now < freezeCooldownUntil) return;
      freezeUntil = now + CONFIG.freezeDuration;
      freezeCooldownUntil = now + CONFIG.freezeCooldown;

      flash.classList.add("on");
      setTimeout(() => flash.classList.remove("on"), 120);

      // Small UX update
      prayerEl.textContent = "COOLDOWN";
    }

    function updatePrayerUI(now) {
      if (now < freezeCooldownUntil) {
        const left = Math.max(0, (freezeCooldownUntil - now) / 1000);
        prayerEl.textContent = left.toFixed(1) + "s";
      } else {
        prayerEl.textContent = "K√âSZ";
      }
    }

    // ---------------------------
    // INPUT (touch + mouse)
    // ---------------------------
    function pointerToCanvasXY(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left);
      const y = (e.clientY - rect.top);
      return { x, y };
    }

    function onPointerDown(e) {
      if (!running) return;
      e.preventDefault();

      // double tap: on touch we also get pointer events; detect by time delta
      const now = performance.now();
      if (now - lastTapAt <= DOUBLE_TAP_MS) {
        tryFreeze(now);
        lastTapAt = 0;
      } else {
        lastTapAt = now;
      }

      player.dragging = true;
      const p = pointerToCanvasXY(e);
      player.targetX = p.x;
      player.targetY = p.y;
    }

    function onPointerMove(e) {
      if (!running) return;
      if (!player.dragging) return;
      e.preventDefault();
      const p = pointerToCanvasXY(e);
      player.targetX = p.x;
      player.targetY = p.y;
    }

    function onPointerUp(e) {
      if (!running) return;
      player.dragging = false;
    }

    canvas.addEventListener("pointerdown", onPointerDown, { passive: false });
    canvas.addEventListener("pointermove", onPointerMove, { passive: false });
    canvas.addEventListener("pointerup", onPointerUp, { passive: true });
    canvas.addEventListener("pointercancel", onPointerUp, { passive: true });

    // Prevent scroll / bounce on mobile while playing
    document.addEventListener("touchmove", (e) => { if (running) e.preventDefault(); }, { passive: false });

    // ---------------------------
    // GAME LOOP
    // ---------------------------
    function start() {
      resetGame();
      hideOverlay();
      running = true;
      tStart = performance.now();
      lastFrame = tStart;
      requestAnimationFrame(loop);
    }

    function endLose() {
      running = false;
      gameOver = true;
      showOverlay("retry");
    }

    function endWin() {
      running = false;
      won = true;
      showOverlay("win");
    }

    function loop(now) {
      if (!running) return;

      const dt = Math.min(0.033, (now - lastFrame) / 1000); // cap dt for stability
      lastFrame = now;

      survived = (now - tStart) / 1000;
      timeEl.textContent = survived.toFixed(1);

      // Win condition
      if (survived >= CONFIG.goalSeconds) {
        endWin();
        return;
      }

      updatePrayerUI(now);

      // Spawn logic (gets faster)
      spawnTimer += dt * 1000;
      const spawnEvery = currentSpawnEveryMs();
      while (spawnTimer >= spawnEvery) {
        spawnTimer -= spawnEvery;
        spawnLion();
      }

      // Update player (smooth follow finger; still playable if finger jumps)
      const w = cssW(), h = cssH();
      player.targetX = clamp(player.targetX, player.r, w - player.r);
      player.targetY = clamp(player.targetY, player.r, h - player.r);
      const follow = 18; // higher = snappier
      player.x += (player.targetX - player.x) * clamp(follow * dt, 0, 1);
      player.y += (player.targetY - player.y) * clamp(follow * dt, 0, 1);

      // Freeze?
      const frozen = now < freezeUntil;

      // Update lions
      const speed = currentLionSpeed();
      for (let i = lions.length - 1; i >= 0; i--) {
        const L = lions[i];

        if (!frozen) {
          // Move towards player + a tiny wobble so it's not perfectly straight
          const dx = player.x - L.x;
          const dy = player.y - L.y;
          const len = Math.hypot(dx, dy) || 1;

          // wobble perpendicular
          const px = -dy / len;
          const py = dx / len;
          const wob = L.wobble;

          const vx = (dx / len) * speed + px * (speed * 0.12 * wob);
          const vy = (dy / len) * speed + py * (speed * 0.12 * wob);

          L.x += vx * dt;
          L.y += vy * dt;
        }

        // Despawn if far outside (saves perf)
        if (L.x < -120 || L.x > w + 120 || L.y < -120 || L.y > h + 120) {
          // keep some around; don't despawn if near player
          if (dist2(L.x, L.y, player.x, player.y) > (Math.max(w, h) * 0.9) ** 2) {
            lions.splice(i, 1);
            continue;
          }
        }

        // Collision
        const rr = (L.r + player.r) * (L.r + player.r);
        if (dist2(L.x, L.y, player.x, player.y) <= rr) {
          endLose();
          return;
        }
      }

      draw(frozen);
      requestAnimationFrame(loop);
    }

    // ---------------------------
    // RENDER
    // ---------------------------
    function draw(frozen=false) {
      const w = cssW(), h = cssH();
      ctx.clearRect(0, 0, w, h);

      // subtle vignette
      ctx.save();
      const g = ctx.createRadialGradient(w*0.5, h*0.5, 40, w*0.5, h*0.5, Math.max(w,h)*0.65);
      g.addColorStop(0, "rgba(255,255,255,0.05)");
      g.addColorStop(1, "rgba(0,0,0,0.55)");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, w, h);
      ctx.restore();

      // Floor "stone" dots (cheap texture)
      ctx.save();
      ctx.globalAlpha = 0.12;
      for (let i=0; i<22; i++) {
        const x = (i*37 + (survived*12)) % (w+80) - 40;
        const y = (i*71 + (survived*8)) % (h+80) - 40;
        ctx.beginPath();
        ctx.arc(x, y, 2 + (i%3), 0, Math.PI*2);
        ctx.fillStyle = "white";
        ctx.fill();
      }
      ctx.restore();

      // Lions
      for (const L of lions) {
        // lion as emoji bubble for "gagyi" vibe
        drawEmojiBubble("ü¶Å", L.x, L.y, L.r, frozen);
      }

      // Player (Daniel)
      drawEmojiBubble("üßî‚Äç‚ôÇÔ∏è", player.x, player.y, player.r, false);

      // Freeze overlay on canvas (subtle)
      if (frozen) {
        ctx.save();
        ctx.fillStyle = "rgba(120,180,255,0.10)";
        ctx.fillRect(0, 0, w, h);
        ctx.restore();
      }

      // small instruction bottom
      ctx.save();
      ctx.globalAlpha = 0.75;
      ctx.fillStyle = "rgba(0,0,0,0.30)";
      ctx.fillRect(10, h - 44, w - 20, 34);
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = "white";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("H√∫zd az ujjad: mozg√°s ‚Ä¢ Dupla tap: ima (fagyaszt)", 18, h - 22);
      ctx.restore();
    }

    function drawEmojiBubble(emoji, x, y, r, frozen) {
      // background circle
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, r + 6, 0, Math.PI * 2);
      ctx.fillStyle = frozen ? "rgba(110,170,255,0.22)" : "rgba(255,255,255,0.10)";
      ctx.fill();

      ctx.beginPath();
      ctx.arc(x, y, r + 6, 0, Math.PI * 2);
      ctx.strokeStyle = frozen ? "rgba(160,210,255,0.30)" : "rgba(255,255,255,0.16)";
      ctx.lineWidth = 1;
      ctx.stroke();

      // emoji
      ctx.font = `${Math.floor((r + 8) * 1.45)}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(emoji, x, y + 1);
      ctx.restore();
    }
  
    // ---------------------------
    // UI buttons
    // ---------------------------
    btnStart.addEventListener("click", () => start());
    btnRetry.addEventListener("click", () => start());

    // Start screen
    resetGame();
    showOverlay("start");
  </script>
</body>
</html>
